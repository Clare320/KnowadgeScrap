## Swift中强循环问题

### 类之间强引用循环
类的实例彼此引用。
### 闭包强引用循环

闭包是引用类型，。

出现强引用的情况：
  闭包作为类的对象属性，在闭包体里面又使用类的其它对象属性。这时候就会导致类的对象强持有闭包属性，闭包又捕获到类的对象进而强持有类对象，形成强循环。

解决方法：**定义捕获数组**
> 在Swift里面闭包里面使用`self.someProperty`或`self.someFunc()`来代替`someProperty`或`someFunc()`，这样可以提醒你捕获到self

在捕获数组中元素是成对出现的，格式为`weak`或`unowned`开头+已经声明的类的对象或其它地方已声明的变量，这些元素用`[]`包围，多个元素用`,`隔开，放在参数数组之前。

Weak Refrence 弱引用

  使用场景：当捕获的对象可能在未来的某个点变为`nil`。弱引用总是一个可变类型，并且在对象被释放后置为`nil`。这样可以在闭包体里面判断当前对象是否存在。

  > 如果捕获到的引用无法变为nil，它应该总是是一个无主引用关系而不应是一个弱引用。

Unowned Refrence 无主引用

  使用场景： 当闭包和它所捕获的类的对象总是相互指向对方，并且也总是在同一个时间点释放。

### 分析
#### 从生命周期考虑
引用被`unowned`修饰的对象的生命周期的实例和`owned`引用有着共同的声明的周期或者更长的生命周期。

`weaked`修饰的两个生命周期相互独立。在使用的情况下可以为nil。但是在使用时也要验证有效性。

#### 从性能特性考虑

弱引用最常见的实现是，每次一个新的引用生成时，都会将弱引用和其指向的对象信息存储到一个附加表中去。  
**零和弱引用** -> 当没有任何一个强引用指向一个对象时，`Swift`运行时将会启动析构过程，但是在这之前，会将所有相关的弱引用都置为nil。  

这种实现有实际的开销，考虑到需要额外实现的数据结构，需要确保在并发访问情况下，对这个全局引用结构所有操作的正确性。一旦析构过程开始了，在任何环境中，都不允许访问弱引用所指向的对象了。  

弱引用（包括 unowned 和一些变体的 weak)在 Swift 使用了更简单和快速的实现机制。  

Swift 中的每个对象保持了两个引用计数器，一个是强引用计数器，用来决定 ARC 什么时候可以安全地析构这个对象，另外一个附加的弱引用计数器，用来计算创建了多少个指向这个对象的 unowned 或者 weak 引用，当这个计数器为零时，这个对象将被 析构 。
需要重点理解的是，只有等到所有 unowned 引用被释放后，这个对象才会被真正地析构，然后对象将会保持未解析可访问状态，当析构发生后，对象的内容才会被回收。  

每当 unowned 引用被定义时，对应的 unowned 引用计数会进行原子级别地增加(使用原子gcc/llvm操作，进行一系列快速且线程安全的基本操作，例如：增加，减少，比较，交换等)，以保证线程安全。在增加计数之前，会检查强引用计数以确保对象是有效的。
试图访问一个无效的对象，将会导致错误的断言，你的应用在运行时中会报错(这就是为什么这里的 unownd 实现方式叫做 unowned(safe) 实现)。  

为了更好的优化，应用编译时带有 -OFast，unowned 引用不会去验证引用对象的有效性，unowned 引用的行为就会像 Objective-C 中的` __unsafe_unretained` 一样。如果引用对象无效，unowned 引用将会指向已经释放垃圾内存（这种实现称之 unowned(unsafe)）。
当一个 unowned 引用被释放后，如果这时没有其他强引用或 unowned 引用指向这个对象，那么最终这个对象将被析构。这就是为什么一个引用对象不能在强引用计数器等于零的情况下，被析构的原因，所有的引用计数器必须能够被访问用来验证 unowned 引用和强引用数量。  

Swift 的 weak 引用添加了附加层，间接地把 unowned 引用包裹到了一个可选容器里面，在指向的对象析构之后变成空的情况下，这样处理会更加的清晰。但是需要付出的代价是，附加的机制需要正确地处理可选值。
考虑到以上因素，在对象关系生命周期允许的情况下，优先选择使用 unowned 引用。但是这不是此故事的结局，接下来比较一下两者性能上的差别。


## Object-C中Block强循环问题 （这里目前还是说不清）

强引用一个对象，使被引用的对象的引用计数无法变为0，无法执行析构过程，不能被释放。

  解决强引用的步骤：

  1. 弱引用对象
  2. 再强引用定义好的弱引用对象
  3. 判断强引用的有效性
